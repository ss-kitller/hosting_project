#!/usr/bin/env python
"""
Script de scraping des navires pr√©visionnels depuis le site ANP
URL: https://anp.org.ma/fr/services/mvm-navires
"""

import os
import sys
import django
import time
import csv
from datetime import datetime
from selenium import webdriver
from selenium.webdriver.support.ui import Select
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from bs4 import BeautifulSoup

# Configuration Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')
django.setup()

from manutention.models import NavirePrevisionnel
from django.utils import timezone

def scrape_navires_anp():
    """
    Scraper les donn√©es des navires depuis le site ANP et les sauvegarder en CSV
    Bas√© sur le script original de l'utilisateur
    """
    print("üöÄ D√©but du scraping des navires depuis ANP...")
    
    # Configuration Chrome headless
    chrome_options = Options()
    chrome_options.add_argument("--headless")
    chrome_options.add_argument("--no-sandbox")
    chrome_options.add_argument("--disable-dev-shm-usage")
    chrome_options.add_argument("--disable-gpu")
    chrome_options.add_argument("--window-size=1920,1080")
    chrome_options.add_argument("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
    
    driver = None
    try:
        driver = webdriver.Chrome(options=chrome_options)
        driver.get("https://anp.org.ma/fr/services/mvm-navires")
        
        print("üîó Navigation vers le site ANP...")
        
        wait = WebDriverWait(driver, 20)
        dropdown = wait.until(EC.presence_of_element_located((By.NAME, "Ports")))
        
        select = Select(dropdown)
        select.select_by_visible_text("Port d'Agadir")
        
        print("üìç S√©lection du port d'Agadir...")
        time.sleep(6)
        
        # V√©rifier le nombre de r√©sultats affich√©
        try:
            result_text = driver.find_element(By.XPATH, "//*[contains(text(), 'R√âSULTAT') or contains(text(), 'r√©sultat')]").text
            print(f"üìä Texte de r√©sultats trouv√©: {result_text}")
        except:
            print("‚ÑπÔ∏è Texte de r√©sultats non trouv√©")
        
        # Essayer de trouver un s√©lecteur pour afficher plus de r√©sultats par page
        try:
            # Chercher un dropdown pour le nombre d'√©l√©ments par page
            selectors = [
                "select[name*='page']",
                "select[name*='limit']", 
                "select[name*='size']",
                ".page-size select",
                "[class*='page-size'] select",
                "select[onchange*='page']",
                "select[id*='page']",
                "select[class*='page']",
                "select option[value*='100']",
                "select option[value*='50']"
            ]
            
            for selector in selectors:
                try:
                    page_size_select = driver.find_element(By.CSS_SELECTOR, selector)
                    if page_size_select:
                        print(f"üîç S√©lecteur de taille de page trouv√©: {selector}")
                        # Essayer de s√©lectionner la plus grande valeur
                        options = page_size_select.find_elements(By.TAG_NAME, "option")
                        max_value = "100"  # Valeur par d√©faut
                        for option in options:
                            value = option.get_attribute("value")
                            if value and value.isdigit() and int(value) > int(max_value):
                                max_value = value
                        
                        if max_value != "100":
                            Select(page_size_select).select_by_value(max_value)
                            print(f"üìÑ Taille de page chang√©e √† {max_value}")
                            time.sleep(3)
                        break
                except:
                    continue
        except Exception as e:
            print(f"‚ÑπÔ∏è Impossible de modifier la taille de page: {e}")
        
        # Attendre que le tableau se charge compl√®tement
        time.sleep(3)
        
        # V√©rifier s'il y a une pagination - chercher plus de s√©lecteurs
        pagination_selectors = [
            ".pagination a", ".pager a", "[class*='page']",
            "a[href*='page']", "button[onclick*='page']",
            ".pagination li a", ".pager li a",
            "[class*='pagination'] a", "[class*='pager'] a"
        ]
        
        pagination_elements = []
        for selector in pagination_selectors:
            try:
                elements = driver.find_elements(By.CSS_SELECTOR, selector)
                if elements:
                    pagination_elements.extend(elements)
                    print(f"üîç S√©lecteur '{selector}' trouv√©: {len(elements)} √©l√©ments")
            except:
                continue
        
        # Supprimer les doublons
        pagination_elements = list(set(pagination_elements))
        print(f"üîç Total √©l√©ments de pagination trouv√©s: {len(pagination_elements)}")
        
        # Afficher les textes des √©l√©ments de pagination
        for i, elem in enumerate(pagination_elements[:10]):  # Limiter √† 10 pour √©viter trop de logs
            try:
                text = elem.get_text(strip=True)
                print(f"üìÑ √âl√©ment pagination {i+1}: '{text}'")
            except:
                print(f"üìÑ √âl√©ment pagination {i+1}: [texte non lisible]")
        
        all_rows_data = []
        
        # Si pas de pagination, r√©cup√©rer directement
        if not pagination_elements:
            soup = BeautifulSoup(driver.page_source, "html.parser")
            table = soup.find("table")
            
            if table:
                rows = table.find_all("tr")
                print(f"üìä {len(rows)} lignes trouv√©es dans le tableau (pas de pagination)")
                
                for i, row in enumerate(rows):
                    cols = [td.get_text(strip=True) for td in row.find_all("td")]
                    if cols:
                        print(f"üìã Ligne {i+1}: {cols}")
                        all_rows_data.append(cols)
            else:
                print("‚ùå Tableau non trouv√© sur la page")
                return {
                    'success': False,
                    'error': 'Tableau non trouv√© sur la page ANP'
                }
        else:
            # G√©rer la pagination
            print("üìÑ Pagination d√©tect√©e, r√©cup√©ration de toutes les pages...")
            page_num = 1
            
            while True:
                print(f"üìÑ Traitement de la page {page_num}...")
                
                # Attendre que le tableau se charge
                time.sleep(2)
                
                soup = BeautifulSoup(driver.page_source, "html.parser")
                table = soup.find("table")
                
                if table:
                    rows = table.find_all("tr")
                    print(f"üìä {len(rows)} lignes trouv√©es sur la page {page_num}")
                    
                    for i, row in enumerate(rows):
                        cols = [td.get_text(strip=True) for td in row.find_all("td")]
                        if cols:
                            print(f"üìã Page {page_num}, Ligne {i+1}: {cols}")
                            all_rows_data.append(cols)
                
                # Chercher le bouton "Suivant" ou "Next" - logique am√©lior√©e
                next_button = None
                next_texts = ['suivant', 'next', '>', '¬ª', 'suiv.', 'next page', 'page suivante']
                
                for element in pagination_elements:
                    try:
                        text = element.get_text(strip=True).lower()
                        href = element.get_attribute("href") or ""
                        onclick = element.get_attribute("onclick") or ""
                        
                        # V√©rifier le texte
                        if any(next_text in text for next_text in next_texts):
                            next_button = element
                            print(f"üîç Bouton suivant trouv√© par texte: '{text}'")
                            break
                        
                        # V√©rifier l'attribut href
                        if "page" in href.lower() and any(str(i) in href for i in range(2, 10)):
                            next_button = element
                            print(f"üîç Bouton suivant trouv√© par href: '{href}'")
                            break
                            
                        # V√©rifier onclick
                        if "page" in onclick.lower() and any(str(i) in onclick for i in range(2, 10)):
                            next_button = element
                            print(f"üîç Bouton suivant trouv√© par onclick: '{onclick}'")
                            break
                            
                    except Exception as e:
                        print(f"‚ö†Ô∏è Erreur lors de l'analyse de l'√©l√©ment: {e}")
                        continue
                
                if next_button:
                    try:
                        # V√©rifier si le bouton est cliquable
                        if next_button.is_enabled() and next_button.is_displayed():
                            print(f"üñ±Ô∏è Clic sur le bouton suivant pour la page {page_num + 1}")
                            next_button.click()
                            page_num += 1
                            time.sleep(5)  # Attendre plus longtemps pour le chargement
                            
                            # Attendre que le tableau se recharge
                            wait.until(EC.presence_of_element_located((By.TAG_NAME, "table")))
                        else:
                            print("‚ö†Ô∏è Bouton suivant trouv√© mais non cliquable")
                            break
                    except Exception as e:
                        print(f"‚ö†Ô∏è Erreur lors du clic sur le bouton suivant: {e}")
                        break
                else:
                    print("‚úÖ Aucun bouton suivant trouv√© - derni√®re page atteinte")
                    break
        
        rows_data = all_rows_data
        
        print(f"üìä Total navires r√©cup√©r√©s: {len(rows_data)}")
        
        # Sauvegarder en CSV comme dans le script original
        if rows_data:
            csv_filename = "navires_agadir.csv"
            with open(csv_filename, "w", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                writer.writerow(["Nom", "Type", "Statut", "Date", "Heure", "Port", "Consignataire", "Op√©rateur"])
                writer.writerows(rows_data)
            print(f"üíæ Donn√©es sauvegard√©es dans '{csv_filename}'")
            
            # Maintenant ins√©rer les donn√©es dans la base Django
            navires_ajoutes = 0
            
            for cols in rows_data:
                if len(cols) >= 8:
                    # Extraire les donn√©es
                    nom_navire = cols[0]
                    type_navire = cols[1]
                    statut = cols[2]
                    date_str = cols[3]
                    heure_str = cols[4]
                    port = cols[5]
                    consignataire = cols[6]
                    operateur = cols[7]
                    
                    # Validation des donn√©es essentielles
                    if not nom_navire or nom_navire == "Non sp√©cifi√©":
                        continue
                    
                    # Parser la date - logique am√©lior√©e
                    try:
                        date_obj = datetime.strptime(date_str, "%d/%m/%Y").date()
                    except ValueError:
                        # Essayer d'autres formats de date
                        try:
                            date_obj = datetime.strptime(date_str, "%Y-%m-%d").date()
                        except ValueError:
                            try:
                                date_obj = datetime.strptime(date_str, "%m/%d/%Y").date()
                            except ValueError:
                                print(f"‚ö†Ô∏è Format de date non reconnu: {date_str} pour {nom_navire}")
                                continue
                    
                    # Parser l'heure - logique am√©lior√©e
                    try:
                        # Nettoyer l'heure en supprimant les caract√®res en trop
                        heure_clean = heure_str.replace(':', '').replace('h', ':').replace('H', ':')
                        if len(heure_clean) == 4:  # Format HHMM
                            heure_clean = heure_clean[:2] + ':' + heure_clean[2:]
                        elif len(heure_clean) == 3:  # Format HMM
                            heure_clean = '0' + heure_clean[:1] + ':' + heure_clean[1:]
                        
                        heure_obj = datetime.strptime(heure_clean, "%H:%M").time()
                    except ValueError:
                        print(f"‚ö†Ô∏è Format d'heure non reconnu: {heure_str} pour {nom_navire}")
                        continue
                    
                    # Cr√©er le nouveau navire (pas de v√©rification d'existence pour permettre les doublons)
                    navire_data = {
                        'nom': nom_navire,
                        'type': type_navire,
                        'statut': statut,
                        'date_arrivee': date_obj,
                        'heure_arrivee': heure_obj,
                        'port': port,
                        'consignataire': consignataire,
                        'operateur': operateur
                    }
                    
                    NavirePrevisionnel.objects.create(**navire_data)
                    navires_ajoutes += 1
        else:
            print("‚ùå Aucune donn√©e trouv√©e")
            return {
                'success': False,
                'error': 'Aucune donn√©e trouv√©e'
            }
        
        print(f"\nüìà R√©sum√© du scraping:")
        print(f"   - Navires ajout√©s: {navires_ajoutes}")
        print(f"   - Total trait√©: {len(rows_data)}")
        print(f"   - Navires rejet√©s (donn√©es invalides): {len(rows_data) - navires_ajoutes}")
        
        # Afficher les navires rejet√©s pour diagnostic
        rejected_count = 0
        for cols in rows_data:
            if len(cols) >= 8:
                nom_navire = cols[0]
                date_str = cols[3]
                heure_str = cols[4]
                
                # V√©rifier pourquoi le navire a √©t√© rejet√©
                if not nom_navire or nom_navire == "Non sp√©cifi√©":
                    print(f"‚ùå Navire rejet√© - nom invalide: {nom_navire}")
                    rejected_count += 1
                    continue
                
                try:
                    date_obj = datetime.strptime(date_str, "%d/%m/%Y").date()
                except ValueError:
                    print(f"‚ùå Navire rejet√© - date invalide: {date_str} pour {nom_navire}")
                    rejected_count += 1
                    continue
                
                try:
                    heure_obj = datetime.strptime(heure_str, "%H:%M").time()
                except ValueError:
                    print(f"‚ùå Navire rejet√© - heure invalide: {heure_str} pour {nom_navire}")
                    rejected_count += 1
                    continue
        
        print(f"   - Navires rejet√©s d√©taill√©s: {rejected_count}")
        
        return {
            'success': True,
            'navires_ajoutes': navires_ajoutes,
            'total_traite': len(rows_data),
            'csv_file': csv_filename
        }
        
    except Exception as e:
        print(f"‚ùå Erreur lors du scraping: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }
    finally:
        if driver:
            driver.quit()
            print("üîí Navigateur ferm√©")

if __name__ == "__main__":
    result = scrape_navires_anp()
    print(f"R√©sultat: {result}") 